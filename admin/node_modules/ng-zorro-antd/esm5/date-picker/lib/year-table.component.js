/**
 * @fileoverview added by tsickle
 * Generated from: lib/year-table.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { __extends } from "tslib";
/**
 * @license
 * Copyright Alibaba.com All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
import { ChangeDetectionStrategy, Component, ViewEncapsulation } from '@angular/core';
import { valueFunctionProp } from 'ng-zorro-antd/core/util';
import { DateHelperService } from 'ng-zorro-antd/i18n';
import { AbstractTable } from './abstract-table';
var YearTableComponent = /** @class */ (function (_super) {
    __extends(YearTableComponent, _super);
    function YearTableComponent(dateHelper) {
        var _this = _super.call(this) || this;
        _this.dateHelper = dateHelper;
        _this.MAX_ROW = 4;
        _this.MAX_COL = 3;
        return _this;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    YearTableComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        _super.prototype.ngOnChanges.call(this, changes);
        if (changes.value || changes.disabledDate || changes.activeDate) {
            this.render();
        }
    };
    /**
     * @return {?}
     */
    YearTableComponent.prototype.makeHeadRow = /**
     * @return {?}
     */
    function () {
        return [];
    };
    /**
     * @return {?}
     */
    YearTableComponent.prototype.makeBodyRows = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var currentYear = this.activeDate && this.activeDate.getYear();
        /** @type {?} */
        var startYear = parseInt("" + currentYear / 10, 10) * 10;
        /** @type {?} */
        var endYear = startYear + 9;
        /** @type {?} */
        var previousYear = startYear - 1;
        /** @type {?} */
        var years = [];
        /** @type {?} */
        var yearValue = 0;
        for (var rowIndex = 0; rowIndex < this.MAX_ROW; rowIndex++) {
            /** @type {?} */
            var row = [];
            var _loop_1 = function (colIndex) {
                /** @type {?} */
                var yearNum = previousYear + yearValue;
                /** @type {?} */
                var year = this_1.activeDate.setYear(yearNum);
                /** @type {?} */
                var content = this_1.dateHelper.format(year.nativeDate, 'yyyy');
                /** @type {?} */
                var isDisabled = this_1.disabledDate ? this_1.disabledDate(year.nativeDate) : false;
                /** @type {?} */
                var cell = {
                    value: year.nativeDate,
                    isDisabled: isDisabled,
                    isSameDecade: yearNum >= startYear && yearNum <= endYear,
                    isSelected: yearNum === (this_1.value && this_1.value.getYear()),
                    content: content,
                    title: content,
                    classMap: {},
                    cellRender: valueFunctionProp((/** @type {?} */ (this_1.cellRender)), year),
                    // Customized content
                    fullCellRender: valueFunctionProp((/** @type {?} */ (this_1.fullCellRender)), year),
                    onClick: (/**
                     * @return {?}
                     */
                    function () { return _this.chooseYear(cell.value.getFullYear()); }),
                    // don't use yearValue here,
                    onMouseEnter: (/**
                     * @return {?}
                     */
                    function () { return null; })
                };
                cell.classMap = this_1.getClassMap(cell);
                row.push(cell);
                yearValue++;
            };
            var this_1 = this;
            for (var colIndex = 0; colIndex < this.MAX_COL; colIndex++) {
                _loop_1(colIndex);
            }
            years.push({ dateCells: row });
        }
        return years;
    };
    /**
     * @param {?} cell
     * @return {?}
     */
    YearTableComponent.prototype.getClassMap = /**
     * @param {?} cell
     * @return {?}
     */
    function (cell) {
        var _a;
        return _a = {},
            _a[this.prefixCls + "-cell"] = true,
            _a[this.prefixCls + "-cell-in-view"] = !!cell.isSameDecade,
            _a[this.prefixCls + "-cell-selected"] = cell.isSelected,
            _a[this.prefixCls + "-cell-disabled"] = cell.isDisabled,
            _a;
    };
    /**
     * @private
     * @param {?} year
     * @return {?}
     */
    YearTableComponent.prototype.chooseYear = /**
     * @private
     * @param {?} year
     * @return {?}
     */
    function (year) {
        this.value = this.activeDate.setYear(year);
        this.valueChange.emit(this.value);
        this.render();
    };
    YearTableComponent.decorators = [
        { type: Component, args: [{
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    // tslint:disable-next-line:component-selector
                    selector: 'year-table',
                    exportAs: 'yearTable',
                    template: "<table class=\"ant-picker-content\" cellspacing=\"0\" role=\"grid\">\n  <thead *ngIf=\"headRow && headRow.length > 0\">\n    <tr role=\"row\">\n      <th *ngIf=\"showWeek\" role=\"columnheader\"></th>\n      <th *ngFor=\"let cell of headRow\" role=\"columnheader\" title=\"{{ cell.title }}\">\n        {{ cell.content }}\n      </th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr *ngFor=\"let row of bodyRows; trackBy: trackByBodyRow\" [ngClass]=\"row.classMap!\" role=\"row\">\n      <td *ngIf=\"row.weekNum\" role=\"gridcell\" class=\"{{ prefixCls }}-cell-week\">\n        {{ row.weekNum }}\n      </td>\n      <td\n        *ngFor=\"let cell of row.dateCells; trackBy: trackByBodyColumn\"\n        title=\"{{ cell.title }}\"\n        role=\"gridcell\"\n        [ngClass]=\"cell.classMap!\"\n        (click)=\"cell.isDisabled ? null : cell.onClick()\"\n        (mouseenter)=\"cell.onMouseEnter()\"\n      >\n        <ng-container [ngSwitch]=\"prefixCls\">\n          <ng-container *ngSwitchCase=\"'ant-picker'\">\n            <ng-container [ngSwitch]=\"true\">\n              <ng-container *ngSwitchCase=\"isTemplateRef(cell.cellRender)\">\n                <!--           *ngSwitchCase not has type assertion support, the cellRender type here is TemplateRef -->\n                <ng-container\n                  *ngTemplateOutlet=\"$any(cell.cellRender); context: { $implicit: cell.value }\"\n                ></ng-container>\n              </ng-container>\n              <ng-container *ngSwitchCase=\"isNonEmptyString(cell.cellRender)\">\n                <span [innerHTML]=\"cell.cellRender\"></span>\n              </ng-container>\n              <ng-container *ngSwitchDefault>\n                <div\n                  class=\"{{ prefixCls }}-cell-inner\"\n                  [attr.aria-selected]=\"cell.isSelected\"\n                  [attr.aria-disabled]=\"cell.isDisabled\"\n                >\n                  {{ cell.content }}\n                </div>\n              </ng-container>\n            </ng-container>\n          </ng-container>\n          <ng-container *ngSwitchCase=\"'ant-picker-calendar'\">\n            <div\n              class=\"{{ prefixCls }}-date ant-picker-cell-inner\"\n              [class.ant-picker-calendar-date-today]=\"cell.isToday\"\n            >\n              <ng-container *ngIf=\"cell.fullCellRender; else defaultCell\">\n                <ng-container\n                  *ngTemplateOutlet=\"$any(cell.fullCellRender); context: { $implicit: cell.value }\"\n                >\n                </ng-container>\n              </ng-container>\n              <ng-template #defaultCell>\n                <div class=\"{{ prefixCls }}-date-value\">{{ cell.content }}</div>\n                <div class=\"{{ prefixCls }}-date-content\">\n                  <ng-container\n                    *ngTemplateOutlet=\"$any(cell.cellRender); context: { $implicit: cell.value }\"\n                  >\n                  </ng-container>\n                </div>\n              </ng-template>\n            </div>\n          </ng-container>\n        </ng-container>\n      </td>\n    </tr>\n  </tbody>\n</table>\n"
                }] }
    ];
    /** @nocollapse */
    YearTableComponent.ctorParameters = function () { return [
        { type: DateHelperService }
    ]; };
    return YearTableComponent;
}(AbstractTable));
export { YearTableComponent };
if (false) {
    /** @type {?} */
    YearTableComponent.prototype.MAX_ROW;
    /** @type {?} */
    YearTableComponent.prototype.MAX_COL;
    /**
     * @type {?}
     * @private
     */
    YearTableComponent.prototype.dateHelper;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieWVhci10YWJsZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZy16b3Jyby1hbnRkL2RhdGUtcGlja2VyLyIsInNvdXJjZXMiOlsibGliL3llYXItdGFibGUuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFRQSxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsU0FBUyxFQUE0QixpQkFBaUIsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNoSCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUM1RCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUN2RCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFHakQ7SUFRd0Msc0NBQWE7SUFJbkQsNEJBQW9CLFVBQTZCO1FBQWpELFlBQ0UsaUJBQU8sU0FDUjtRQUZtQixnQkFBVSxHQUFWLFVBQVUsQ0FBbUI7UUFIakQsYUFBTyxHQUFHLENBQUMsQ0FBQztRQUNaLGFBQU8sR0FBRyxDQUFDLENBQUM7O0lBSVosQ0FBQzs7Ozs7SUFFRCx3Q0FBVzs7OztJQUFYLFVBQVksT0FBc0I7UUFDaEMsaUJBQU0sV0FBVyxZQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQzNCLElBQUksT0FBTyxDQUFDLEtBQUssSUFBSSxPQUFPLENBQUMsWUFBWSxJQUFJLE9BQU8sQ0FBQyxVQUFVLEVBQUU7WUFDL0QsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1NBQ2Y7SUFDSCxDQUFDOzs7O0lBRUQsd0NBQVc7OztJQUFYO1FBQ0UsT0FBTyxFQUFFLENBQUM7SUFDWixDQUFDOzs7O0lBRUQseUNBQVk7OztJQUFaO1FBQUEsaUJBdUNDOztZQXRDTyxXQUFXLEdBQUcsSUFBSSxDQUFDLFVBQVUsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRTs7WUFDMUQsU0FBUyxHQUFHLFFBQVEsQ0FBQyxLQUFHLFdBQVcsR0FBRyxF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QUNsQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDaEIsQ0FBQzs7Z0JBakZGLFNBQVMsU0FBQztvQkFDVCxhQUFhLEVBQUUsaUJBQWlCLENBQUMsSUFBSTtvQkFDckMsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07O29CQUUvQyxRQUFRLEVBQUUsWUFBWTtvQkFDdEIsUUFBUSxFQUFFLFdBQVc7b0JBQ3JCLG9rR0FBa0M7aUJBQ25DOzs7O2dCQVhRLGlCQUFpQjs7SUFzRjFCLHlCQUFDO0NBQUEsQUFsRkQsQ0FRd0MsYUFBYSxHQTBFcEQ7U0ExRVksa0JBQWtCOzs7SUFDN0IscUNBQVk7O0lBQ1oscUNBQVk7Ozs7O0lBRUEsd0NBQXFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFsaWJhYmEuY29tIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9naXRodWIuY29tL05HLVpPUlJPL25nLXpvcnJvLWFudGQvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICovXG5cbmltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIE9uQ2hhbmdlcywgU2ltcGxlQ2hhbmdlcywgVmlld0VuY2Fwc3VsYXRpb24gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IHZhbHVlRnVuY3Rpb25Qcm9wIH0gZnJvbSAnbmctem9ycm8tYW50ZC9jb3JlL3V0aWwnO1xuaW1wb3J0IHsgRGF0ZUhlbHBlclNlcnZpY2UgfSBmcm9tICduZy16b3Jyby1hbnRkL2kxOG4nO1xuaW1wb3J0IHsgQWJzdHJhY3RUYWJsZSB9IGZyb20gJy4vYWJzdHJhY3QtdGFibGUnO1xuaW1wb3J0IHsgRGF0ZUJvZHlSb3csIERhdGVDZWxsLCBZZWFyQ2VsbCB9IGZyb20gJy4vaW50ZXJmYWNlJztcblxuQENvbXBvbmVudCh7XG4gIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6Y29tcG9uZW50LXNlbGVjdG9yXG4gIHNlbGVjdG9yOiAneWVhci10YWJsZScsXG4gIGV4cG9ydEFzOiAneWVhclRhYmxlJyxcbiAgdGVtcGxhdGVVcmw6ICdhYnN0cmFjdC10YWJsZS5odG1sJ1xufSlcbmV4cG9ydCBjbGFzcyBZZWFyVGFibGVDb21wb25lbnQgZXh0ZW5kcyBBYnN0cmFjdFRhYmxlIGltcGxlbWVudHMgT25DaGFuZ2VzIHtcbiAgTUFYX1JPVyA9IDQ7XG4gIE1BWF9DT0wgPSAzO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZGF0ZUhlbHBlcjogRGF0ZUhlbHBlclNlcnZpY2UpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgIHN1cGVyLm5nT25DaGFuZ2VzKGNoYW5nZXMpO1xuICAgIGlmIChjaGFuZ2VzLnZhbHVlIHx8IGNoYW5nZXMuZGlzYWJsZWREYXRlIHx8IGNoYW5nZXMuYWN0aXZlRGF0ZSkge1xuICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9XG4gIH1cblxuICBtYWtlSGVhZFJvdygpOiBEYXRlQ2VsbFtdIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBtYWtlQm9keVJvd3MoKTogRGF0ZUJvZHlSb3dbXSB7XG4gICAgY29uc3QgY3VycmVudFllYXIgPSB0aGlzLmFjdGl2ZURhdGUgJiYgdGhpcy5hY3RpdmVEYXRlLmdldFllYXIoKTtcbiAgICBjb25zdCBzdGFydFllYXIgPSBwYXJzZUludChgJHtjdXJyZW50WWVhciAvIDEwfWAsIDEwKSAqIDEwO1xuICAgIGNvbnN0IGVuZFllYXIgPSBzdGFydFllYXIgKyA5O1xuICAgIGNvbnN0IHByZXZpb3VzWWVhciA9IHN0YXJ0WWVhciAtIDE7XG5cbiAgICBjb25zdCB5ZWFyczogRGF0ZUJvZHlSb3dbXSA9IFtdO1xuXG4gICAgbGV0IHllYXJWYWx1ZSA9IDA7XG4gICAgZm9yIChsZXQgcm93SW5kZXggPSAwOyByb3dJbmRleCA8IHRoaXMuTUFYX1JPVzsgcm93SW5kZXgrKykge1xuICAgICAgY29uc3Qgcm93OiBEYXRlQ2VsbFtdID0gW107XG4gICAgICBmb3IgKGxldCBjb2xJbmRleCA9IDA7IGNvbEluZGV4IDwgdGhpcy5NQVhfQ09MOyBjb2xJbmRleCsrKSB7XG4gICAgICAgIGNvbnN0IHllYXJOdW0gPSBwcmV2aW91c1llYXIgKyB5ZWFyVmFsdWU7XG4gICAgICAgIGNvbnN0IHllYXIgPSB0aGlzLmFjdGl2ZURhdGUuc2V0WWVhcih5ZWFyTnVtKTtcbiAgICAgICAgY29uc3QgY29udGVudCA9IHRoaXMuZGF0ZUhlbHBlci5mb3JtYXQoeWVhci5uYXRpdmVEYXRlLCAneXl5eScpO1xuICAgICAgICBjb25zdCBpc0Rpc2FibGVkID0gdGhpcy5kaXNhYmxlZERhdGUgPyB0aGlzLmRpc2FibGVkRGF0ZSh5ZWFyLm5hdGl2ZURhdGUpIDogZmFsc2U7XG5cbiAgICAgICAgY29uc3QgY2VsbDogWWVhckNlbGwgPSB7XG4gICAgICAgICAgdmFsdWU6IHllYXIubmF0aXZlRGF0ZSxcbiAgICAgICAgICBpc0Rpc2FibGVkLFxuICAgICAgICAgIGlzU2FtZURlY2FkZTogeWVhck51bSA+PSBzdGFydFllYXIgJiYgeWVhck51bSA8PSBlbmRZZWFyLFxuICAgICAgICAgIGlzU2VsZWN0ZWQ6IHllYXJOdW0gPT09ICh0aGlzLnZhbHVlICYmIHRoaXMudmFsdWUuZ2V0WWVhcigpKSxcbiAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgIHRpdGxlOiBjb250ZW50LFxuICAgICAgICAgIGNsYXNzTWFwOiB7fSxcbiAgICAgICAgICBjZWxsUmVuZGVyOiB2YWx1ZUZ1bmN0aW9uUHJvcCh0aGlzLmNlbGxSZW5kZXIhLCB5ZWFyKSwgLy8gQ3VzdG9taXplZCBjb250ZW50XG4gICAgICAgICAgZnVsbENlbGxSZW5kZXI6IHZhbHVlRnVuY3Rpb25Qcm9wKHRoaXMuZnVsbENlbGxSZW5kZXIhLCB5ZWFyKSxcbiAgICAgICAgICBvbkNsaWNrOiAoKSA9PiB0aGlzLmNob29zZVllYXIoY2VsbC52YWx1ZS5nZXRGdWxsWWVhcigpKSwgLy8gZG9uJ3QgdXNlIHllYXJWYWx1ZSBoZXJlLFxuICAgICAgICAgIG9uTW91c2VFbnRlcjogKCkgPT4gbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIGNlbGwuY2xhc3NNYXAgPSB0aGlzLmdldENsYXNzTWFwKGNlbGwpO1xuXG4gICAgICAgIHJvdy5wdXNoKGNlbGwpO1xuICAgICAgICB5ZWFyVmFsdWUrKztcbiAgICAgIH1cbiAgICAgIHllYXJzLnB1c2goeyBkYXRlQ2VsbHM6IHJvdyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHllYXJzO1xuICB9XG5cbiAgZ2V0Q2xhc3NNYXAoY2VsbDogWWVhckNlbGwpOiB7IFtrZXk6IHN0cmluZ106IGJvb2xlYW4gfSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtgJHt0aGlzLnByZWZpeENsc30tY2VsbGBdOiB0cnVlLFxuICAgICAgW2Ake3RoaXMucHJlZml4Q2xzfS1jZWxsLWluLXZpZXdgXTogISFjZWxsLmlzU2FtZURlY2FkZSxcbiAgICAgIFtgJHt0aGlzLnByZWZpeENsc30tY2VsbC1zZWxlY3RlZGBdOiBjZWxsLmlzU2VsZWN0ZWQsXG4gICAgICBbYCR7dGhpcy5wcmVmaXhDbHN9LWNlbGwtZGlzYWJsZWRgXTogY2VsbC5pc0Rpc2FibGVkXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgY2hvb3NlWWVhcih5ZWFyOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLnZhbHVlID0gdGhpcy5hY3RpdmVEYXRlLnNldFllYXIoeWVhcik7XG4gICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHRoaXMudmFsdWUpO1xuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cbn1cbiJdfQ==
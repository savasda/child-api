/**
 * @fileoverview added by tsickle
 * Generated from: modal-footer.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Alibaba.com All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
import { ChangeDetectionStrategy, Component, EventEmitter, Input, Output } from '@angular/core';
import { isPromise } from 'ng-zorro-antd/core/util';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { NzI18nService } from 'ng-zorro-antd/i18n';
import { NzModalRef } from './modal-ref';
import { ModalOptions } from './modal-types';
export class NzModalFooterComponent {
    /**
     * @param {?} i18n
     * @param {?} config
     */
    constructor(i18n, config) {
        this.i18n = i18n;
        this.config = config;
        this.buttonsFooter = false;
        this.buttons = [];
        this.locale = {};
        this.cancelTriggered = new EventEmitter();
        this.okTriggered = new EventEmitter();
        this.destroy$ = new Subject();
        if (Array.isArray(config.nzFooter)) {
            this.buttonsFooter = true;
            this.buttons = ((/** @type {?} */ (config.nzFooter))).map(mergeDefaultOption);
        }
        this.i18n.localeChange.pipe(takeUntil(this.destroy$)).subscribe((/**
         * @return {?}
         */
        () => {
            this.locale = this.i18n.getLocaleData('Modal');
        }));
    }
    /**
     * @return {?}
     */
    onCancel() {
        this.cancelTriggered.emit();
    }
    /**
     * @return {?}
     */
    onOk() {
        this.okTriggered.emit();
    }
    /**
     * Returns the value of the specified key.
     * If it is a function, run and return the return value of the function.
     * @deprecated Not support use function type.
     * \@breaking-change 10.0.0
     * @param {?} options
     * @param {?} prop
     * @return {?}
     */
    getButtonCallableProp(options, prop) {
        /** @type {?} */
        const value = options[prop];
        /** @type {?} */
        const componentInstance = this.modalRef.getContentComponent();
        return typeof value === 'function' ? value.apply(options, componentInstance && [componentInstance]) : value;
    }
    /**
     * Run function based on the type and set its `loading` prop if needed.
     * @deprecated Should be set options' value by the user, not library.
     * \@breaking-change 10.0.0
     * @param {?} options
     * @return {?}
     */
    onButtonClick(options) {
        /** @type {?} */
        const loading = this.getButtonCallableProp(options, 'loading');
        if (!loading) {
            /** @type {?} */
            const result = this.getButtonCallableProp(options, 'onClick');
            if (options.autoLoading && isPromise(result)) {
                options.loading = true;
                result.then((/**
                 * @return {?}
                 */
                () => (options.loading = false))).catch((/**
                 * @return {?}
                 */
                () => (options.loading = false)));
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
}
NzModalFooterComponent.decorators = [
    { type: Component, args: [{
                selector: 'div[nz-modal-footer]',
                exportAs: 'NzModalFooterBuiltin',
                template: `
    <ng-container *ngIf="config.nzFooter; else defaultFooterButtons">
      <ng-container *nzStringTemplateOutlet="config.nzFooter">
        <div *ngIf="!buttonsFooter" [innerHTML]="config.nzTitle"></div>
        <ng-container *ngIf="buttonsFooter">
          <button
            *ngFor="let button of buttons"
            nz-button
            (click)="onButtonClick(button)"
            [hidden]="!getButtonCallableProp(button, 'show')"
            [nzLoading]="getButtonCallableProp(button, 'loading')"
            [disabled]="getButtonCallableProp(button, 'disabled')"
            [nzType]="button.type!"
            [nzShape]="button.shape!"
            [nzSize]="button.size!"
            [nzGhost]="button.ghost!"
          >
            {{ button.label }}
          </button>
        </ng-container>
      </ng-container>
    </ng-container>
    <ng-template #defaultFooterButtons>
      <button
        *ngIf="config.nzCancelText !== null"
        [attr.cdkFocusInitial]="config.nzAutofocus === 'cancel'"
        nz-button
        (click)="onCancel()"
        [nzLoading]="!!config.nzCancelLoading"
        [disabled]="config.nzCancelDisabled"
      >
        {{ config.nzCancelText || locale.cancelText }}
      </button>
      <button
        *ngIf="config.nzOkText !== null"
        [attr.cdkFocusInitial]="config.nzAutofocus === 'ok'"
        nz-button
        [nzType]="config.nzOkType!"
        (click)="onOk()"
        [nzLoading]="!!config.nzOkLoading"
        [disabled]="config.nzOkDisabled"
      >
        {{ config.nzOkText || locale.okText }}
      </button>
    </ng-template>
  `,
                host: {
                    class: 'ant-modal-footer'
                },
                changeDetection: ChangeDetectionStrategy.Default
            }] }
];
/** @nocollapse */
NzModalFooterComponent.ctorParameters = () => [
    { type: NzI18nService },
    { type: ModalOptions }
];
NzModalFooterComponent.propDecorators = {
    cancelTriggered: [{ type: Output }],
    okTriggered: [{ type: Output }],
    modalRef: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    NzModalFooterComponent.prototype.buttonsFooter;
    /** @type {?} */
    NzModalFooterComponent.prototype.buttons;
    /** @type {?} */
    NzModalFooterComponent.prototype.locale;
    /** @type {?} */
    NzModalFooterComponent.prototype.cancelTriggered;
    /** @type {?} */
    NzModalFooterComponent.prototype.okTriggered;
    /** @type {?} */
    NzModalFooterComponent.prototype.modalRef;
    /**
     * @type {?}
     * @private
     */
    NzModalFooterComponent.prototype.destroy$;
    /**
     * @type {?}
     * @private
     */
    NzModalFooterComponent.prototype.i18n;
    /** @type {?} */
    NzModalFooterComponent.prototype.config;
}
/**
 * @param {?} options
 * @return {?}
 */
function mergeDefaultOption(options) {
    return Object.assign({ type: null, size: 'default', autoLoading: true, show: true, loading: false, disabled: false }, options);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9kYWwtZm9vdGVyLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25nLXpvcnJvLWFudGQvbW9kYWwvIiwic291cmNlcyI6WyJtb2RhbC1mb290ZXIuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQVFBLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBYSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0csT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQ3BELE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDL0IsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRTNDLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUVuRCxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBQ3pDLE9BQU8sRUFBc0IsWUFBWSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBd0RqRSxNQUFNLE9BQU8sc0JBQXNCOzs7OztJQVNqQyxZQUFvQixJQUFtQixFQUFTLE1BQW9CO1FBQWhELFNBQUksR0FBSixJQUFJLENBQWU7UUFBUyxXQUFNLEdBQU4sTUFBTSxDQUFjO1FBUnBFLGtCQUFhLEdBQUcsS0FBSyxDQUFDO1FBQ3RCLFlBQU8sR0FBeUIsRUFBRSxDQUFDO1FBQ25DLFdBQU0sR0FBNkMsRUFBRSxDQUFDO1FBQ25DLG9CQUFlLEdBQUcsSUFBSSxZQUFZLEVBQVEsQ0FBQztRQUMzQyxnQkFBVyxHQUFHLElBQUksWUFBWSxFQUFRLENBQUM7UUFFbEQsYUFBUSxHQUFHLElBQUksT0FBTyxFQUFRLENBQUM7UUFHckMsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsRUFBRTtZQUNsQyxJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQztZQUMxQixJQUFJ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TyxFQUFFLEtBQUssRUFDZCxRQUFRLEVBQUUsS0FBSyxJQUNaLE9BQU8sRUFDVjtBQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWxpYmFiYS5jb20gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2dpdGh1Yi5jb20vTkctWk9SUk8vbmctem9ycm8tYW50ZC9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKi9cblxuaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25EZXN0cm95LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGlzUHJvbWlzZSB9IGZyb20gJ25nLXpvcnJvLWFudGQvY29yZS91dGlsJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgTnpJMThuU2VydmljZSB9IGZyb20gJ25nLXpvcnJvLWFudGQvaTE4bic7XG5cbmltcG9ydCB7IE56TW9kYWxSZWYgfSBmcm9tICcuL21vZGFsLXJlZic7XG5pbXBvcnQgeyBNb2RhbEJ1dHRvbk9wdGlvbnMsIE1vZGFsT3B0aW9ucyB9IGZyb20gJy4vbW9kYWwtdHlwZXMnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdkaXZbbnotbW9kYWwtZm9vdGVyXScsXG4gIGV4cG9ydEFzOiAnTnpNb2RhbEZvb3RlckJ1aWx0aW4nLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJjb25maWcubnpGb290ZXI7IGVsc2UgZGVmYXVsdEZvb3RlckJ1dHRvbnNcIj5cbiAgICAgIDxuZy1jb250YWluZXIgKm56U3RyaW5nVGVtcGxhdGVPdXRsZXQ9XCJjb25maWcubnpGb290ZXJcIj5cbiAgICAgICAgPGRpdiAqbmdJZj1cIiFidXR0b25zRm9vdGVyXCIgW2lubmVySFRNTF09XCJjb25maWcubnpUaXRsZVwiPjwvZGl2PlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiYnV0dG9uc0Zvb3RlclwiPlxuICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICpuZ0Zvcj1cImxldCBidXR0b24gb2YgYnV0dG9uc1wiXG4gICAgICAgICAgICBuei1idXR0b25cbiAgICAgICAgICAgIChjbGljayk9XCJvbkJ1dHRvbkNsaWNrKGJ1dHRvbilcIlxuICAgICAgICAgICAgW2hpZGRlbl09XCIhZ2V0QnV0dG9uQ2FsbGFibGVQcm9wKGJ1dHRvbiwgJ3Nob3cnKVwiXG4gICAgICAgICAgICBbbnpMb2FkaW5nXT1cImdldEJ1dHRvbkNhbGxhYmxlUHJvcChidXR0b24sICdsb2FkaW5nJylcIlxuICAgICAgICAgICAgW2Rpc2FibGVkXT1cImdldEJ1dHRvbkNhbGxhYmxlUHJvcChidXR0b24sICdkaXNhYmxlZCcpXCJcbiAgICAgICAgICAgIFtuelR5cGVdPVwiYnV0dG9uLnR5cGUhXCJcbiAgICAgICAgICAgIFtuelNoYXBlXT1cImJ1dHRvbi5zaGFwZSFcIlxuICAgICAgICAgICAgW256U2l6ZV09XCJidXR0b24uc2l6ZSFcIlxuICAgICAgICAgICAgW256R2hvc3RdPVwiYnV0dG9uLmdob3N0IVwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAge3sgYnV0dG9uLmxhYmVsIH19XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgPC9uZy1jb250YWluZXI+XG4gICAgPG5nLXRlbXBsYXRlICNkZWZhdWx0Rm9vdGVyQnV0dG9ucz5cbiAgICAgIDxidXR0b25cbiAgICAgICAgKm5nSWY9XCJjb25maWcubnpDYW5jZWxUZXh0ICE9PSBudWxsXCJcbiAgICAgICAgW2F0dHIuY2RrRm9jdXNJbml0aWFsXT1cImNvbmZpZy5uekF1dG9mb2N1cyA9PT0gJ2NhbmNlbCdcIlxuICAgICAgICBuei1idXR0b25cbiAgICAgICAgKGNsaWNrKT1cIm9uQ2FuY2VsKClcIlxuICAgICAgICBbbnpMb2FkaW5nXT1cIiEhY29uZmlnLm56Q2FuY2VsTG9hZGluZ1wiXG4gICAgICAgIFtkaXNhYmxlZF09XCJjb25maWcubnpDYW5jZWxEaXNhYmxlZFwiXG4gICAgICA+XG4gICAgICAgIHt7IGNvbmZpZy5uekNhbmNlbFRleHQgfHwgbG9jYWxlLmNhbmNlbFRleHQgfX1cbiAgICAgIDwvYnV0dG9uPlxuICAgICAgPGJ1dHRvblxuICAgICAgICAqbmdJZj1cImNvbmZpZy5uek9rVGV4dCAhPT0gbnVsbFwiXG4gICAgICAgIFthdHRyLmNka0ZvY3VzSW5pdGlhbF09XCJjb25maWcubnpBdXRvZm9jdXMgPT09ICdvaydcIlxuICAgICAgICBuei1idXR0b25cbiAgICAgICAgW256VHlwZV09XCJjb25maWcubnpPa1R5cGUhXCJcbiAgICAgICAgKGNsaWNrKT1cIm9uT2soKVwiXG4gICAgICAgIFtuekxvYWRpbmddPVwiISFjb25maWcubnpPa0xvYWRpbmdcIlxuICAgICAgICBbZGlzYWJsZWRdPVwiY29uZmlnLm56T2tEaXNhYmxlZFwiXG4gICAgICA+XG4gICAgICAgIHt7IGNvbmZpZy5uek9rVGV4dCB8fCBsb2NhbGUub2tUZXh0IH19XG4gICAgICA8L2J1dHRvbj5cbiAgICA8L25nLXRlbXBsYXRlPlxuICBgLFxuICBob3N0OiB7XG4gICAgY2xhc3M6ICdhbnQtbW9kYWwtZm9vdGVyJ1xuICB9LFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LkRlZmF1bHRcbn0pXG5leHBvcnQgY2xhc3MgTnpNb2RhbEZvb3RlckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIGJ1dHRvbnNGb290ZXIgPSBmYWxzZTtcbiAgYnV0dG9uczogTW9kYWxCdXR0b25PcHRpb25zW10gPSBbXTtcbiAgbG9jYWxlOiB7IG9rVGV4dD86IHN0cmluZzsgY2FuY2VsVGV4dD86IHN0cmluZyB9ID0ge307XG4gIEBPdXRwdXQoKSByZWFkb25seSBjYW5jZWxUcmlnZ2VyZWQgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG4gIEBPdXRwdXQoKSByZWFkb25seSBva1RyaWdnZXJlZCA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcbiAgQElucHV0KCkgbW9kYWxSZWYhOiBOek1vZGFsUmVmO1xuICBwcml2YXRlIGRlc3Ryb3kkID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGkxOG46IE56STE4blNlcnZpY2UsIHB1YmxpYyBjb25maWc6IE1vZGFsT3B0aW9ucykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZy5uekZvb3RlcikpIHtcbiAgICAgIHRoaXMuYnV0dG9uc0Zvb3RlciA9IHRydWU7XG4gICAgICB0aGlzLmJ1dHRvbnMgPSAoY29uZmlnLm56Rm9vdGVyIGFzIE1vZGFsQnV0dG9uT3B0aW9uc1tdKS5tYXAobWVyZ2VEZWZhdWx0T3B0aW9uKTtcbiAgICB9XG4gICAgdGhpcy5pMThuLmxvY2FsZUNoYW5nZS5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIHRoaXMubG9jYWxlID0gdGhpcy5pMThuLmdldExvY2FsZURhdGEoJ01vZGFsJyk7XG4gICAgfSk7XG4gIH1cblxuICBvbkNhbmNlbCgpOiB2b2lkIHtcbiAgICB0aGlzLmNhbmNlbFRyaWdnZXJlZC5lbWl0KCk7XG4gIH1cblxuICBvbk9rKCk6IHZvaWQge1xuICAgIHRoaXMub2tUcmlnZ2VyZWQuZW1pdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBzcGVjaWZpZWQga2V5LlxuICAgKiBJZiBpdCBpcyBhIGZ1bmN0aW9uLCBydW4gYW5kIHJldHVybiB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbi5cbiAgICogQGRlcHJlY2F0ZWQgTm90IHN1cHBvcnQgdXNlIGZ1bmN0aW9uIHR5cGUuXG4gICAqIEBicmVha2luZy1jaGFuZ2UgMTAuMC4wXG4gICAqL1xuICBnZXRCdXR0b25DYWxsYWJsZVByb3Aob3B0aW9uczogTW9kYWxCdXR0b25PcHRpb25zLCBwcm9wOiBrZXlvZiBNb2RhbEJ1dHRvbk9wdGlvbnMpOiBib29sZWFuIHtcbiAgICBjb25zdCB2YWx1ZSA9IG9wdGlvbnNbcHJvcF07XG4gICAgY29uc3QgY29tcG9uZW50SW5zdGFuY2UgPSB0aGlzLm1vZGFsUmVmLmdldENvbnRlbnRDb21wb25lbnQoKTtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gdmFsdWUuYXBwbHkob3B0aW9ucywgY29tcG9uZW50SW5zdGFuY2UgJiYgW2NvbXBvbmVudEluc3RhbmNlXSkgOiB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW4gZnVuY3Rpb24gYmFzZWQgb24gdGhlIHR5cGUgYW5kIHNldCBpdHMgYGxvYWRpbmdgIHByb3AgaWYgbmVlZGVkLlxuICAgKiBAZGVwcmVjYXRlZCBTaG91bGQgYmUgc2V0IG9wdGlvbnMnIHZhbHVlIGJ5IHRoZSB1c2VyLCBub3QgbGlicmFyeS5cbiAgICogQGJyZWFraW5nLWNoYW5nZSAxMC4wLjBcbiAgICovXG4gIG9uQnV0dG9uQ2xpY2sob3B0aW9uczogTW9kYWxCdXR0b25PcHRpb25zKTogdm9pZCB7XG4gICAgY29uc3QgbG9hZGluZyA9IHRoaXMuZ2V0QnV0dG9uQ2FsbGFibGVQcm9wKG9wdGlvbnMsICdsb2FkaW5nJyk7XG4gICAgaWYgKCFsb2FkaW5nKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmdldEJ1dHRvbkNhbGxhYmxlUHJvcChvcHRpb25zLCAnb25DbGljaycpO1xuICAgICAgaWYgKG9wdGlvbnMuYXV0b0xvYWRpbmcgJiYgaXNQcm9taXNlKHJlc3VsdCkpIHtcbiAgICAgICAgb3B0aW9ucy5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgcmVzdWx0LnRoZW4oKCkgPT4gKG9wdGlvbnMubG9hZGluZyA9IGZhbHNlKSkuY2F0Y2goKCkgPT4gKG9wdGlvbnMubG9hZGluZyA9IGZhbHNlKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5kZXN0cm95JC5uZXh0KCk7XG4gICAgdGhpcy5kZXN0cm95JC5jb21wbGV0ZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlRGVmYXVsdE9wdGlvbihvcHRpb25zOiBNb2RhbEJ1dHRvbk9wdGlvbnMpOiBNb2RhbEJ1dHRvbk9wdGlvbnMge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IG51bGwsXG4gICAgc2l6ZTogJ2RlZmF1bHQnLFxuICAgIGF1dG9Mb2FkaW5nOiB0cnVlLFxuICAgIHNob3c6IHRydWUsXG4gICAgbG9hZGluZzogZmFsc2UsXG4gICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbn1cbiJdfQ==